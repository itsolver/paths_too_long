# Toolset for Handling Long Filepaths

This toolset is designed to address filepaths that exceed the 260 character limit typically found in Windows file servers. It can be particularly useful for migrating file shares to SharePoint. The toolset comprises three scripts, each with a specific function:


### paths_too_long.py

`paths_too_long.py` is a straightforward script that prompts the user in the console to input a filepath. It then iterates through the directories within that path, gathering information about the files. Any files with a path length exceeding 260 characters are excluded from the dataset. The resulting data is saved into a CSV file.

### fix_paths2long.py

`fix_paths2long.py` launches a graphical user interface (GUI) using the spreadsheet generated by `paths_too_long.py`. The goal is to collect user input for modifying directory names within the paths to reduce their length. To begin, the user is asked to specify the CSV file to be used, which should be located in the same directory as `fix_paths2long.py`. The script generates a dataframe from the CSV file and iterates through each row, creating a tkinter frame for each path called the "ChooseSegmentFrame." A sample image of this frame can be found in 'fix_paths2long-ChooseSegmentFrame-example.jpg'. This frame includes four rows:

- Row 1 displays the entire path.
- Row 2 contains buttons corresponding to each directory in the path, allowing the user to select the directory name to be changed.
- Row 3 indicates how many other file paths in the dataframe share each directory in the path, aiding in batch changes.
- Row 4 displays the length of the longest filepath in the dataframe containing the corresponding directory. The length of the current path (row 1) is provided at the end of this row. This information helps users determine how many characters need to be removed from each directory in the filepath to comply with the 260-character Windows path limit.

When the user selects a directory button from row 2 in the ChooseSegmentFrame, it triggers the creation of the next frame, known as the "FixSegmentFrame," a sample image of which can be seen in 'fix_paths2long-FixSegmentFrame-example.jpg'. This frame includes the directory name, a pre-populated text entry box with the directory name, an 'enter' button, and a 'write changes to CSV' button. Users can make desired changes to the directory name in the text field and click the 'enter' button to save the name change for all affected file paths in the dataframe. The 'write changes to CSV' button on the FixSegmentFrame frame saves the dataframe with the corrected paths to the CSV file, effectively preserving the user's progress. Notably, the shortened filepaths are now stored in an additional row within the CSV file.

### apply_file2long_fixes.py

The purpose of `apply_file2long_fixes.py` is to implement the directory and file name changes recorded in the `fix_paths2long.py` script. The script begins by requesting the name of the CSV file generated by `paths_too_long.py` with corrections made by `fix_paths2long.py`. This CSV file should be located in the same directory as the script. `apply_file2long_fixes.py` then processes the dataframe generated from the CSV file, adding an additional attribute, 'depth,' which represents the number of directories between the directory modified in `fix_paths2long.py` and the root directory.

Starting with file paths requiring the deepest directory or file name changes, the script iterates through the dataframe, making the necessary modifications and recording the updated path for all affected rows in a column labeled 'intermediary_paths.' The latest filepath change is recorded in a 'result_path' column, and any encountered errors during path location or modification are logged in an 'error' column. The result is a dataframe containing a list of all filepath changes in the 'intermediary_paths' column and the actual resulting file location in the 'result_path' column. This dataframe is then saved to the CSV file.